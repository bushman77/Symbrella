defmodule Brain.LIFG.Stage2 do
  @moduledoc """
  LIFG.Stage2 — commitment arbitration and suppression.

  Stage2 sits between Stage1 (competitive sense selection) and downstream
  integration (WM, ATL, Hippocampus).

  Responsibilities (current):
    • Select a single dominant MWE (if any)
    • Suppress weaker overlapping MWEs and weak unigrams
    • Commit high-confidence winners
    • Defer low-margin winners
    • Emit a clear, auditable Stage2 trace event

  Non-responsibilities (by design):
    • No re-scoring
    • No beam search
    • No PMTG consultation
    • No WM mutation
    • No sense flipping

  This keeps Stage2 principled, deterministic, and low-risk.
  """

  require Logger

  @type si :: map()
  @type choice :: map()

  @type decision ::
          {:commit, choice()}
          | {:defer, choice(), reason :: atom()}
          | {:collapse, mwe_choice :: choice(), suppressed :: [choice()]}

  @type opts :: [
          reanalysis_margin_threshold: float()
        ]

  @default_opts [
    reanalysis_margin_threshold: 0.10
  ]

  # ───────────────────────── Public API ─────────────────────────

  @spec run(si(), opts()) ::
          {:ok, %{si: si(), event: map()}}
          | {:skip, %{si: si(), reason: atom()}}
          | {:error, term()}
def run(%{trace: trace} = si, opts) when is_list(trace) do
  if Enum.any?(trace, &(&1[:stage] == :lifg_stage1)) and
       not Keyword.get(opts, :enable_stage2, false) do
    {:skip, %{si: si, reason: :not_enabled}}
  else
    do_run(si, opts)
  end
end

  # ───────────────────────── Decision Core ─────────────────────────

  @spec decide([choice()], opts()) :: [decision()]
  def decide(choices, opts) when is_list(choices) do
    threshold = Keyword.fetch!(opts, :reanalysis_margin_threshold)

    {mwes, unigrams} =
      Enum.split_with(choices, &Map.get(&1, :mw?, false))

    dominant_mwe = select_dominant_mwe(mwes)

    {collapse_decisions, suppressed_unigram_idxs} =
      collapse_from_dominant_mwe(dominant_mwe, unigrams, threshold)

    mwe_deferrals =
      mwes
      |> Enum.reject(&(&1 == dominant_mwe))
      |> Enum.map(&{:defer, &1, :suppressed_by_dominant_mwe})

    unigram_decisions =
      unigrams
      |> Enum.reject(&MapSet.member?(suppressed_unigram_idxs, &1.token_index))
      |> Enum.map(&commit_or_defer(&1, threshold))

    collapse_decisions ++ mwe_deferrals ++ unigram_decisions
  end

  # ───────────────────────── Commitment Logic ─────────────────────────

  defp commit_or_defer(choice, threshold) do
    if weak?(choice, threshold) do
      {:defer, choice, :low_margin}
    else
      {:commit, choice}
    end
  end

  defp weak?(choice, threshold) do
    Map.get(choice, :margin, 0.0) < threshold
  end

  # ───────────────────────── Dominant MWE ─────────────────────────

  @spec select_dominant_mwe([choice()]) :: choice() | nil
  defp select_dominant_mwe([]), do: nil

  defp select_dominant_mwe(mwes) do
    mwes
    |> Enum.sort_by(fn mwe ->
      {
        -mwe_span_size(mwe),
        -Map.get(mwe, :margin, 0.0),
        Map.get(mwe, :token_index, 0)
      }
    end)
    |> hd()
  end

  defp mwe_span_size(%{span: {s, e}})
       when is_integer(s) and is_integer(e),
       do: e - s

  defp mwe_span_size(%{n: n}) when is_integer(n), do: n
  defp mwe_span_size(_), do: 0

  # ───────────────────────── Span Suppression ─────────────────────────

  defp collapse_from_dominant_mwe(nil, _unigrams, _threshold),
    do: {[], MapSet.new()}

  defp collapse_from_dominant_mwe(mwe, unigrams, threshold) do
    suppressed =
      Enum.filter(unigrams, fn u ->
        weak?(u, threshold) and covers_span?(mwe, u)
      end)

    decisions =
      if suppressed == [] do
        [{:commit, mwe}]
      else
        [{:collapse, mwe, suppressed}]
      end

    idxs =
      suppressed
      |> Enum.map(& &1.token_index)
      |> MapSet.new()

    {decisions, idxs}
  end

  defp covers_span?(%{span: {s1, e1}}, %{span: {s2, e2}})
       when is_integer(s1) and is_integer(e1) and
              is_integer(s2) and is_integer(e2) do
    s1 <= s2 and e1 >= e2
  end

  defp covers_span?(_, _), do: false

  # ───────────────────────── Trace Event ─────────────────────────

  defp stage2_event(stage1_event, decisions) do
    {committed, deferred, collapsed} =
      Enum.reduce(decisions, {[], [], []}, fn
        {:commit, c}, {cm, df, cl} ->
          {[c.chosen_id | cm], df, cl}

        {:defer, c, _}, {cm, df, cl} ->
          {cm, [c.chosen_id | df], cl}

        {:collapse, mwe, suppressed}, {cm, df, cl} ->
          {
            [mwe.chosen_id | cm],
            df,
            [{mwe.chosen_id, Enum.map(suppressed, & &1.chosen_id)} | cl]
          }
      end)

    %{
      stage: :lifg_stage2,
      source_stage1: stage1_event[:stage],
      committed: Enum.reverse(committed),
      deferred: Enum.reverse(deferred),
      collapsed: Enum.reverse(collapsed),
      ts_ms: System.system_time(:millisecond)
    }
  end

  # ───────────────────────── Stage1 Snapshot ─────────────────────────

  defp stage1_snapshot(%{} = si) do
    case Map.get(si, :trace) do
      trace when is_list(trace) ->
        case Enum.find(trace, &(&1[:stage] == :lifg_stage1)) do
          nil -> {:skip, %{si: si, reason: :no_stage1_event}}
          ev -> {:ok, %{si: si, event: ev}}
        end

      _ ->
        {:skip, %{si: si, reason: :no_stage1_event}}
    end
  rescue
    e -> {:error, e}
  end
end

